# ThreadPool

## 内容列表

- [背景](#背景)
- [安装](#安装)
- [设计思路](#设计思路)
- [项目中遇到的问题](#项目中遇到的问题)


## 背景

这个ThreadPool是我写的第一个基于C++的小项目，用于提升自己的C++编程能力，熟悉C++11的多线程库。

开发环境：Ubuntu VsCode

编译器：g++

编译工具：CMake

编程语言：C++

## 设计思路

### 总体流程
- 线程池采用单例模式。首先根据设置的核心线程数预先启动几个**工作线程**；由于此时任务队列为空，所以它们都处于阻塞状态；
- **在工作线程中**，对于核心线程，我使用cv的wait()，就是没有任务一直等；对于临时线程，我是用cv的wait_for版本，如果在有限时间内没有任务要执行，那么就终止线程池；并从工作线程队列中删除；
- **对于线程池的终止**，当要终止线程池时，调用shutdown函数，将结束标志位设为true，同时唤醒所有阻塞的工作线程，若任务队列也为空，那么就结束线程；
- 对于**提交任务**：
	- 如果当前没有等待状态的核心线程，那么就创建临时线程；
	- 为了处理任务可能参数量不一样的情况，然后使用可变模板参数和bind绑定器统一将函数转化成无参函数，提交到任务队列中。
	- 这里需要说明的是使用packaged_task而不是function函数对象是为了能获取任务的异步执行结果，任务队列使用std::function<void()，是因为packaged_task<return_type()>的return_type是可变的。用智能指针来包裹packaged_task对象，是因为跨线程传递堆对象，智能指针可以自动析构。
- 为了防止线程池中的线程还没有执行完就被析构，我采用了RAII机制，在ThreadPool类中定义了一个join_threads，它的构造函数是一个指向线程map的引用，另外在它的析构函数中会遍历每一个thread并执行join()函数。它是ThreadPool类中最后一个被声明的成员变量，因此会最先被析构。所以当ThreadPool被析构时，会首先执行join_threads的析构函数，防止程序因为在thread还在执行时，因为threadpool被析构而导致崩溃。

### 线程池创建需要的那几个核心参数的含义
- corePoolSize：线程池中的核心线程数
- maximumPoolSize：线程池中最大线程数
- keepAliveTime：闲置超时时间
- workQueue：线程池中的任务队列
- rejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略（待实现）

### 线程池中核心线程数量大小
- 如果是CPU密集型任务，比如像加解密，压缩、计算等一系列需要大量耗费 CPU 资源的任务，大部分场景下都是纯 CPU 计算。尽量使用较小的线程池，一般为CPU核心数+1。若设置过多的线程数，会导致CPU频繁切换上下文导致开销过大。
- 如果是IO密集型任务，比如像文件的读写、网络通信等任务，这类任务对CPU的使用率不高，但是 IO 操作比较耗时，会占用比较多时间。因此可以使用稍大的线程池，一般为2*CPU核心数。


## 项目中遇到的问题

在我测试的时候我将for循环中的循环变量i通过lambda传给了线程去执行，但由于lambda中我使用了引用捕获，导致变量i的输出一直不对。使用值捕获就正确了。


待继续补充！！！


